create table dbo.product
(
product_id int identity(1,1) primary key, -- clustered
year_introduced int not null,
);

create table dbo.product_i18n
(
product_i18n_id int identity(1,1) primary key,
product_id int not null,
language_code nvarchar(6) not null,
product_name nvarchar(100) not null,
product_description nvarchar(100) not null,
constraint uk_product_i18n unique(product_id, language_code)
);

-- Why we should use unique key(instead of primary key) on many-to-many fields(uk_product_i18n): http://www.ienablemuch.com/2012/11/page-splitting-with-clustered-composite.html

declare @productId int;

insert into product(year_introduced) 
values(1976);
set @productId = SCOPE_IDENTITY();
insert into dbo.product_i18n(product_id, language_code, product_name, product_description)
values(@productId, 'en', 'Apple I','First Personal Computer');
insert into dbo.product_i18n(product_id, language_code, product_name, product_description)
values(@productId, 'zh', 'Pingguo Xian','Xian Dian Nao');



insert into product(year_introduced) 
values(2007);
set @productId = SCOPE_IDENTITY();
insert into dbo.product_i18n(product_id, language_code, product_name, product_description)
values(@productId, 'en', 'iPhone','First Truly Smartphone');


insert into product(year_introduced) 
values(1964);
set @productId = SCOPE_IDENTITY();
insert into dbo.product_i18n(product_id, language_code, product_name, product_description)
values(@productId, 'ph', 'Sarao', 'World''s Top Jeepney Brand');


insert into product(year_introduced) 
values(1994);
set @productId = SCOPE_IDENTITY();
insert into dbo.product_i18n(product_id, language_code, product_name, product_description)
values(@productId, 'zh', 'Anta', 'China''s Top Shoe Brand');


go

create table dbo.ordered_product
(
	ordered_product_id int identity(1,1) primary key,
	ordered_by nvarchar(100) not null,
	date_ordered date not null,
	product_id int not null references product(product_id),	
	qty int not null
);


insert into dbo.ordered_product(product_id, ordered_by, date_ordered, qty) values
(1, 'lapu-lapu', '2013-1-1', 5),
(1, 'andres', '2013-1-2', 11),
(2, 'rizal', '2013-1-1', 11);



go




create function dbo.tvf_get_product_sold() 
returns table
as
	return
		select p.product_id, ordered_count = coalesce(sum(o.qty), 0)
		from dbo.product p			
		left join dbo.ordered_product o on p.product_id = o.product_id
		group by p.product_id
go


-- select * from  dbo.tvf_get_product_sold() order by product_id





create function dbo.get_product_i18n(@language_code nvarchar(6))
returns table --  (product_id int, language_code nvarchar(6), product_name nvarchar(1000), product_description nvarchar(1000))
as
	return	
		with a as
		(
			select
				-- the_rank =
				row_number() 
				over(partition by product_id
				order by
					case language_code
					when @language_code then 1
					when 'en' then 2
					else 3
					end) 
				as the_rank

				,* 
				,actual_language_code = language_code

			from product_i18n 
		)
		select 			

			-- composite key for ORM:
			a.product_id, language_code = @language_code
			-- ...composite key

			, a.product_name, a.product_description

			, a.actual_language_code
		from a 
		where the_rank = 1;


GO




create function [dbo].[tvf_get_orders_info](@language_code nvarchar(6)) 
returns table
as
	return 
		select
			op.ordered_product_id,
			op.ordered_by, op.date_ordered, pl.product_name, p.year_introduced, op.qty
		from dbo.ordered_product op
		join dbo.get_product_i18n(@language_code) pl on op.product_id = pl.product_id
		join dbo.product p on op.product_id = p.product_id 
go

